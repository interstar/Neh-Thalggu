(ns makedsl.dsl
  (:require [clojure.edn :as edn]
            [clojure.string :as str]
            [clostache.parser :refer [render]]))

(defn parse-dsl-definition [input]
  (try
    (let [lines (str/split-lines input)
          
          ;; Extract DSL name and description from header lines
          name-line (first (filter #(str/starts-with? (str/trim %) "Name:") lines))
          desc-line (first (filter #(str/starts-with? (str/trim %) "Description:") lines))
          
          dsl-name (when name-line
                     (-> name-line
                         (str/replace #".*Name:\s*" "")
                         str/trim))
          description (when desc-line
                        (-> desc-line
                            (str/replace #".*Description:\s*" "")
                            str/trim))
          
          ;; Find the start of the grammar (first line that's not a header)
          grammar-start (->> lines
                            (drop-while #(or (str/starts-with? (str/trim %) "Name:")
                                           (str/starts-with? (str/trim %) "Description:")
                                           (str/blank? (str/trim %))))
                            first)
          grammar-lines (->> lines
                            (drop-while #(or (str/starts-with? (str/trim %) "Name:")
                                           (str/starts-with? (str/trim %) "Description:")
                                           (str/blank? (str/trim %))))
                            (str/join "\n"))
          grammar (str/trim grammar-lines)]
      
      ;; Validate required fields
      (cond
        (or (nil? dsl-name) (str/blank? dsl-name))
        {:success false
         :error "DSL name is required (use 'Name: name')"}
        
        (or (nil? description) (str/blank? description))
        {:success false
         :error "DSL description is required (use 'Description: description')"}
        
        (or (nil? grammar) (str/blank? grammar))
        {:success false
         :error "Grammar is required (provide grammar rules after the header)"}
        
        :else
        ;; Instaparse grammar validation
        (try
          (require 'instaparse.core)
          ((resolve 'instaparse.core/parser) grammar)
        {:success true
         :dsl-name dsl-name
         :description description
           :grammar grammar}
          (catch Exception e
            {:success false
             :error (str "Invalid Instaparse grammar: " (.getMessage e))}))))
    (catch Exception e
      {:success false
       :error (str "Failed to parse DSL definition: " (.getMessage e))})))

(defn generate-namespace [dsl-name]
  (str "(ns " dsl-name ".dsl
  (:require [instaparse.core :as insta]
            [clostache.parser :refer [render]])
  )"))

(defn generate-grammar-def [grammar]
  (str "
(def grammar
  \"" grammar "\")

(def parser (insta/parser grammar))"))

(defn generate-compile-fn [dsl-name]
  (str "
(defn compile-to-target [input tag-path-fn]
  (try
    (let [parse-result (parser input)]
      (if (insta/failure? parse-result)
        {:success false
         :code [\"\"]
         :notes (str input \" is not a valid string in " dsl-name "\")
         :warning \"See :error\"
         :error (-> parse-result insta/get-failure bean str)}
        ;; TODO: Implement actual compilation logic
        {:success true
         :code [\"// Generated code for \" input]
         :notes \"Generated code for " dsl-name " DSL\"
         :warning \"This is a stub implementation\"}))
    (catch Exception e
      {:success false
       :code [\"\"]
       :notes \"Error during compilation\"
       :warning \"See :error\"
       :error (.getMessage e)})))"))

(defn generate-plugin-structure [dsl-name description grammar]
  (str "
(defn get-plugin [tag-path]
  (let [dslname \"" dsl-name "\"]

    {:name dslname
     :description \"" description "\"
     :version \"1.0.0\"
     :author \"Generated by makedsl\"
     :grammar
     {:rules {\"grammar\" \"" grammar "\"}
      :start \"grammar\"}
     :targets
     {\"TARGET_LANGUAGE\"
      {:description \"Generated target for " dsl-name " DSL\"
       :compile-fn (fn [s] (compile-to-target s tag-path))
       :header-fn (fn []
                    {:success true
                     :code \"// TODO: Add required header code for " dsl-name " DSL\"
                     :notes \"Required header for " dsl-name " DSL\"
                     :warning \"This is a stub implementation\"})
       :eyeball-fn (fn [code]
                     (let [issues (cond-> []
                                    (not (re-find #\"ns \" code))
                                    (conj \"Missing namespace declaration\")
                                    (not (re-find #\"defn get-plugin\" code))
                                    (conj \"Missing get-plugin function\")
                                    (not (re-find #\"TARGET_LANGUAGE\" code))
                                    (conj \"Missing TARGET_LANGUAGE placeholder\")
                                    (not (re-find #\"compile-fn\" code))
                                    (conj \"Missing compile-fn\")
                                    (not (re-find #\"header-fn\" code))
                                    (conj \"Missing header-fn\")
                                    (not (re-find #\"eyeball-fn\" code))
                                    (conj \"Missing eyeball-fn\")
                                    )]
                       {:status (if (empty? issues) \"seems ok\" \"issues\")
                        :issues issues
                        :notes \"Checks for required DSL plugin structure\"}))
       :prompts {
                 :compile \"Compiles " dsl-name " DSL input into TARGET_LANGUAGE code.

Arguments:
- dsl: The DSL input to compile (required)

Example:
Input: [Example input for " dsl-name "]
Output: [Generated TARGET_LANGUAGE code]

Notes:
- This is a generated DSL for " description "
- The generated code will be in TARGET_LANGUAGE
- This is the TARGET_LANGUAGE target implementation of the " dsl-name " DSL\"
                 :header \"Gets the required TARGET_LANGUAGE header and dependencies for the " dsl-name " DSL.

Example Output:
// Header code for " dsl-name " DSL

Notes:
- This header provides required dependencies for " dsl-name " DSL generated classes
- This is the TARGET_LANGUAGE target implementation of the " dsl-name " DSL header\"
                 :eyeball \"Performs sanity checks on generated TARGET_LANGUAGE code for the " dsl-name " DSL.

Checks:
- Basic structure validation
- Required components presence

Example:
Input: Generated TARGET_LANGUAGE code
Output: Status and any issues found

Notes:
- Ensures generated code follows the required structure
- Verifies all necessary components are present
- This is the TARGET_LANGUAGE target implementation of the " dsl-name " DSL eyeball function\"
                 }
       }
      }
     }))"))

(defn generate-dsl-clj [dsl-name description grammar]
  (str (generate-namespace dsl-name)
       (generate-grammar-def grammar)
       (generate-compile-fn dsl-name)
       (generate-plugin-structure dsl-name description grammar)))

(defn generate-test-namespace [dsl-name]
  (str "(ns " dsl-name ".test
  (:require [clojure.test :refer :all]
            [" dsl-name ".dsl :refer [get-plugin]]))"))

(defn generate-test-functions [dsl-name]
  (str "
(deftest test-" dsl-name "-plugin
  (testing \"Plugin structure\"
    (let [plugin (get-plugin (fn [& args] args))]
      (is (= \"" dsl-name "\" (:name plugin)))
      (is (contains? (:targets plugin) \"TARGET_LANGUAGE\"))
      (is (fn? (get-in plugin [:targets \"TARGET_LANGUAGE\" :compile-fn])))
      (is (fn? (get-in plugin [:targets \"TARGET_LANGUAGE\" :header-fn])))
      (is (fn? (get-in plugin [:targets \"TARGET_LANGUAGE\" :eyeball-fn]))))))

(deftest test-" dsl-name "-compilation
  (testing \"Basic compilation\"
    (let [plugin (get-plugin (fn [& args] args))
          compile-fn (get-in plugin [:targets \"TARGET_LANGUAGE\" :compile-fn])
          result (compile-fn \"test input\")]
      (is (map? result))
      (is (contains? result :success))
      (is (contains? result :code)))))

(deftest test-" dsl-name "-header
  (testing \"Header generation\"
    (let [plugin (get-plugin (fn [& args] args))
          header-fn (get-in plugin [:targets \"TARGET_LANGUAGE\" :header-fn])
          result (header-fn)]
      (is (map? result))
      (is (contains? result :success))
      (is (contains? result :code)))))

(deftest test-" dsl-name "-eyeball
  (testing \"Eyeball function\"
    (let [plugin (get-plugin (fn [& args] args))
          eyeball-fn (get-in plugin [:targets \"TARGET_LANGUAGE\" :eyeball-fn])
          result (eyeball-fn \"test code\")]
      (is (map? result))
      (is (contains? result :status))
      (is (contains? result :issues)))))

(run-tests)"))

(defn generate-test-clj [dsl-name]
  (str (generate-test-namespace dsl-name)
       (generate-test-functions dsl-name)))

(defn generate-readme-md [dsl-name description]
  (str "# " dsl-name " DSL

The " dsl-name " DSL is a domain-specific language for " (clojure.string/lower-case description) ".

## Syntax

Describe the syntax of your DSL here.

## Examples

### Basic Usage

```
[Example DSL input here]
```

This generates:

```
[Generated output example here]
```

### More Examples

```
[Additional examples]
```

## Generated Code Structure

Describe the structure of the generated code.

## Usage

Explain how to use the generated code.

## Error Handling

The DSL will return an error if:
- [List error conditions]

## Target Language

Currently supports:
- **TARGET_LANGUAGE**: [Description of target language support]
"))

(defn compile-makedsl [input tag-path-fn]
  (try
    (let [parsed (parse-dsl-definition input)]
      (if (:success parsed)
        (let [dsl-clj (generate-dsl-clj (:dsl-name parsed) (:description parsed) (:grammar parsed))
              test-clj (generate-test-clj (:dsl-name parsed))
              readme-md (generate-readme-md (:dsl-name parsed) (:description parsed))]
          {:success true
           :code [dsl-clj test-clj readme-md]
           :notes (str "Generated DSL plugin for " (:dsl-name parsed))
           :warning "This is a template - you'll need to implement the actual compilation logic"})
        {:success false
         :code ["" "" ""]
         :notes "Failed to parse DSL definition"
         :warning "See :error"
         :error (:error parsed)}))
    (catch Exception e
      {:success false
       :code ["" "" ""]
       :notes "Error during DSL generation"
       :warning "See :error"
       :error (.getMessage e)})))

(defn get-plugin [tag-path]
  (let [dslname "makedsl"]

    {:name dslname
     :description "A meta-DSL for generating DSL plugins"
     :version "1.0.0"
     :author "DSL MCP Team"
     :grammar
     {:rules {"DSL_DEFINITION" "COMMENTS GRAMMAR"
              "COMMENTS" "COMMENT_LINE+"
              "COMMENT_LINE" ";; DSL Name: NAME | ;; Description: DESCRIPTION"
              "NAME" "#'[A-Za-z0-9_]+'"
              "DESCRIPTION" "#'[^\\n]+'"
              "GRAMMAR" "EDN_MAP"
              "EDN_MAP" "#'\\{[^}]*\\}'"
              "<SPACE>" "#'\\s+'"}
      :start "DSL_DEFINITION"}
     :targets
     {"clojure"
      {:description "Generate Clojure DSL plugin files"
       :compile-fn (fn [s] (compile-makedsl s tag-path))
       :header-fn (fn []
                    {:success true
                     :code ";; Required dependencies for DSL plugins:
;; [instaparse \"1.4.12\"]
;; [clostache \"1.0.1\"]
;;
;; Example DSL definition format:
;; Name: mydsl
;; Description: A DSL for generating database models
;; S = Entity SPACE 'has' SPACE Property
;; Entity = #'[A-Za-z]+'
;; Property = #'[A-Za-z]+'
;; <SPACE> = #'\\\\s+'
"
                     :notes "Required dependencies and format for DSL definitions"
                     :warning ""})
       :eyeball-fn (fn [code]
                     (let [issues (cond-> []
                                    (not (re-find #"ns " code))
                                    (conj "Missing namespace declaration")
                                    (not (re-find #"defn get-plugin" code))
                                    (conj "Missing get-plugin function")
                                    (not (re-find #"TARGET_LANGUAGE" code))
                                    (conj "Missing TARGET_LANGUAGE placeholder")
                                    (not (re-find #"compile-fn" code))
                                    (conj "Missing compile-fn")
                                    (not (re-find #"header-fn" code))
                                    (conj "Missing header-fn")
                                    (not (re-find #"eyeball-fn" code))
                                    (conj "Missing eyeball-fn")
                                    )]
                       {:status (if (empty? issues) "seems ok" "issues")
                        :issues issues
                        :notes "Checks for required DSL plugin structure"}))
       :prompts {
                 :compile "Compiles DSL definitions into Clojure DSL plugin files.

Arguments:
- dsl: The DSL definition in the format with comments and EDN grammar (required)

Example:
Input: ;; DSL Name: mydsl
;; Description: A DSL for generating database models
{:grammar \"S = Entity SPACE 'has' SPACE Property
          Entity = #'[A-Za-z]+'
          Property = #'[A-Za-z]+'
          <SPACE> = #'\\\\s+'\"}

Output:
// Generated dsl.clj file content
// Generated test_dsl.clj file content

Notes:
- The DSL definition must start with comment lines specifying DSL name and description
- The grammar is specified in EDN format
- Returns two code strings: dsl.clj and test_dsl.clj
- This is the Clojure target implementation of the makedsl DSL"
                 :header "Gets the required dependencies and format information for the makedsl DSL.

Example Output:
;; Required dependencies for DSL plugins:
;; [instaparse \"1.4.12\"]
;; [clostache \"1.0.1\"]
;; Example DSL definition format...

Notes:
- This header provides required dependencies for DSL plugin generation
- Shows the expected format for DSL definitions
- This is the Clojure target implementation of the makedsl DSL header"
                 :eyeball "Performs sanity checks on generated DSL plugin code.

Checks:
- Namespace declaration present
- get-plugin function present
- TARGET_LANGUAGE placeholder present
- Required functions (compile-fn, header-fn, eyeball-fn) present

Example:
Input: Generated DSL plugin code
Output: Status and any issues found

Notes:
- Ensures generated code follows the required DSL plugin structure
- Verifies all necessary components are present
- This is the Clojure target implementation of the makedsl DSL eyeball function"
                 }
       }
      }
     })) 