(ns {{dsl-name}}.dsl
  (:require [instaparse.core :as insta]
            [clojure.string :as str]
            [clojure.data.json :as json]))

(def grammar
  "{{grammar}}")

(def parser (insta/parser grammar))

(defn parse-grammar-rules [grammar-string]
  (let [lines (str/split-lines grammar-string)
        rules (for [line lines
                    :when (and (not (str/blank? line))
                              (not (str/starts-with? line "   ")) ; Skip indented lines
                              (str/includes? line "="))]
                (let [[rule-name rule-body] (str/split line #" = " 2)]
                  [(str/trim rule-name) (str/trim rule-body)]))]
    (into {} rules)))

(defn parse-{{dsl-name}}-input [input tag-path-fn]
  (try
    (let [parse-result (parser input)]
      (if (insta/failure? parse-result)
        (let [failure (insta/get-failure parse-result)]
          {:success false
           :error (str "Parse error at line " (:line failure) ", column " (:column failure) 
                      ": Expected " (:reason failure) 
                      ", but found '" (:text failure) "'")})
        {:success true
         :parsed parse-result}))
    (catch Exception e
      {:success false
       :error (.getMessage e)})))

;; TODO: Add extraction functions for your specific DSL structure
;; Example:
;; (defn extract-command [parsed tag-path-fn]
;;   (let [command-node (tag-path-fn parsed [:S :Command])
;;         command (second command-node)]
;;     command))

(defn compile-to-target [input tag-path-fn load-java-class]
  (try
    (let [parse-result (parse-{{dsl-name}}-input input tag-path-fn)]
      (if (not (:success parse-result))
        {:success false
         :code [""]
         :notes (str input " is not a valid {{dsl-name}} input")
         :warning "See :error"
         :error (:error parse-result)}
        (let [parsed (:parsed parse-result)
              ;; TODO: Extract data from parsed result
              ;; Example:
              ;; command (extract-command parsed tag-path-fn)
              
              ;; Load Java classes from JAR using plugin_loader's load-java-class
              ;; Example:
              ;; MainClass (load-java-class "com.example.MainClass")
              ;; instance (.newInstance MainClass)
              
              ;; TODO: Configure the Java object with extracted data
              ;; Example:
              ;; _ (set! (.command instance) command)
              
              ;; TODO: Generate output
              ;; Example:
              ;; result (.process instance)]
          
          {:success true
           :code ["// TODO: Replace with actual generated output"]
           :notes "Generated output using {{dsl-name}} library"
           :warning "This is a template - implement actual JAR integration"})))
    (catch Exception e
      (println "Exception in compile-to-target:" (.getMessage e))
      (.printStackTrace e)
      {:success false
       :code [""]
       :notes "Error during compilation"
       :warning "See :error"
       :error (.getMessage e)})))

(defn get-metadata []
  {:name "{{dsl-name}}"
   :type :java-jar  ; TODO: Change to :clojure-jar if this is a Clojure library
   :description "{{description}}"
   :version "1.0.0"
   :author "Generated by makedsl foreign target"
   :jar-file "{{dsl-name}}.jar"})

(defn get-plugin [tag-path load-fns]
  (let [dslname "{{dsl-name}}"
        load-java-class (:load-java-class load-fns)]
    {:metadata (get-metadata)
     :grammar
     {:rules (parse-grammar-rules grammar)
      :start "S"}
     :targets
     {"target"
      {:description "Generate output using {{dsl-name}} library"
       :compile-fn (fn [s] (compile-to-target s tag-path load-java-class))
       :header-fn (fn []
                    {:success true
                     :code "{{dsl-name}} Library Integration
This header provides information about the {{dsl-name}} library integration.

The {{dsl-name}} library provides:
- TODO: Describe main functionality
- TODO: Explain key classes and methods
- TODO: Document input/output formats

The library is loaded from {{dsl-name}}.jar and provides:
- TODO: List main classes and their methods
- TODO: Explain how to instantiate and configure objects
- TODO: Document the processing workflow

The output includes generated content based on the {{dsl-name}} DSL input.
The plugin uses the plugin_loader's load-java-class function for robust JAR integration.
JAR loading failures are handled gracefully with proper error reporting."
                     :notes "Information about {{dsl-name}} library integration"
                     :warning "The output is generated using the {{dsl-name}} library"})
       :eyeball-fn (fn [code]
                     (let [issues (cond-> []
                                    (not (re-find #"{{dsl-name}}" code))
                                    (conj "Missing {{dsl-name}} reference")
                                    ;; TODO: Add more specific checks for your output format
                                    )]
                       {:status (if (empty? issues) "seems ok" "issues")
                        :issues issues
                        :notes "Checks for required {{dsl-name}} output content"}))
       :prompts {
                 :compile "Compiles {{dsl-name}} DSL input using the {{dsl-name}} library.

Arguments:
- dsl: The DSL input to compile (required)

Example:
Input: [Example input for {{dsl-name}}]
Output: [Generated output using {{dsl-name}} library]

Implementation Notes:
- Use load-java-class to load classes from the JAR: (load-java-class \"com.example.MainClass\")
- For Java JARs: Instantiate objects directly: (.newInstance MainClass)
- For Java JARs: Configure objects with DSL data: (set! (.property instance) value)
- For Clojure JARs: Call static methods directly: (.method MainClass args)
- For Clojure JARs: You also have load-clojure-namespace available for loading Clojure namespaces
- Call methods directly: (.process instance)
- Handle JAR loading failures gracefully with proper error reporting
- Return {:success false :error \"message\"} when JAR classes cannot be loaded
- This is the target implementation of the {{dsl-name}} DSL"
                 :header "Gets information about the {{dsl-name}} library integration.

Example Output:
{{dsl-name}} Library Integration
This header provides information about the {{dsl-name}} library integration.

Notes:
- The output includes library-specific information
- Generated by calling library methods with DSL parameters
- This is the target implementation of the {{dsl-name}} DSL header"
                 :eyeball "Performs sanity checks on generated {{dsl-name}} output.

Checks:
- {{dsl-name}} reference is present
- TODO: Add more specific checks

Example:
Input: Generated {{dsl-name}} output
Output: Status and any issues found

Notes:
- Ensures output contains all required {{dsl-name}} information
- Verifies the output was properly generated
- This is the target implementation of the {{dsl-name}} DSL eyeball function"
                 }
       }
      }
     }))

;; Return both functions as a map - this is the last expression in the file
{:get-metadata get-metadata
 :get-plugin get-plugin} 