(ns {{dsl-name}}.dsl
  (:require [instaparse.core :as insta]
            [clojure.string :as str]
            [clostache.parser :refer [render]]))

(def grammar
  "{{grammar}}")

(def parser (insta/parser grammar))

(defn parse-grammar-rules [grammar-string]
  (let [lines (str/split-lines grammar-string)
        rules (for [line lines
                    :when (and (not (str/blank? line))
                              (not (str/starts-with? line "   ")) ; Skip indented lines
                              (str/includes? line "="))]
                (let [[rule-name rule-body] (str/split line #" = " 2)]
                  [(str/trim rule-name) (str/trim rule-body)]))]
    (into {} rules)))

(defn compile-to-target [input tag-path-fn]
  (try
    (let [parse-result (parser input)]
      (if (insta/failure? parse-result)
        {:success false
         :code [""]
         :notes (str input " is not a valid string in {{dsl-name}}")
         :warning "See :error"
         :error (-> parse-result insta/get-failure bean str)}
        ;; TODO: Implement actual compilation logic
        {:success true
         :code ["// Generated code for " input]
         :notes "Generated code for {{dsl-name}} DSL"
         :warning "This is a stub implementation"}))
    (catch Exception e
      {:success false
       :code [""]
       :notes "Error during compilation"
       :warning "See :error"
       :error (.getMessage e)})))

(defn get-metadata []
  {:name "{{dsl-name}}"
   :type :native
   :description "{{description}}"
   :version "1.0.0"
   :author "Generated by makedsl"})

(defn get-plugin [tag-path load-fns]
  (let [dslname "{{dsl-name}}"
        grammar-rules (parse-grammar-rules grammar)]
    {:metadata (get-metadata)
     :grammar
     {:rules grammar-rules
      :start "Schema"}
     :targets
     {"TARGET_LANGUAGE"
      {:description "Generated target for {{dsl-name}} DSL"
       :compile-fn (fn [s] (compile-to-target s tag-path))
       :header-fn (fn []
                    {:success true
                     :code "// TODO: Add required header code for {{dsl-name}} DSL"
                     :notes "Required header for {{dsl-name}} DSL"
                     :warning "This is a stub implementation"})
       :eyeball-fn (fn [code]
                     (let [issues (cond-> []
                                    (not (re-find #"ns " code))
                                    (conj "Missing namespace declaration")
                                    (not (re-find #"defn get-plugin" code))
                                    (conj "Missing get-plugin function")
                                    (not (re-find #"TARGET_LANGUAGE" code))
                                    (conj "Missing TARGET_LANGUAGE placeholder")
                                    (not (re-find #"compile-fn" code))
                                    (conj "Missing compile-fn")
                                    (not (re-find #"header-fn" code))
                                    (conj "Missing header-fn")
                                    (not (re-find #"eyeball-fn" code))
                                    (conj "Missing eyeball-fn")
                                    )]
                       {:status (if (empty? issues) "seems ok" "issues")
                        :issues issues
                        :notes "Checks for required DSL plugin structure"}))
       :prompts {
                 :compile "Compiles {{dsl-name}} DSL input into TARGET_LANGUAGE code.

Arguments:
- dsl: The DSL input to compile (required)

Example:
Input: [Example input for {{dsl-name}}]
Output: [Generated TARGET_LANGUAGE code]

Notes:
- This is a generated DSL for {{description}}
- The generated code will be in TARGET_LANGUAGE
- This is the TARGET_LANGUAGE target implementation of the {{dsl-name}} DSL"
                 :header "Gets the required TARGET_LANGUAGE header and dependencies for the {{dsl-name}} DSL.

Example Output:
// Header code for {{dsl-name}} DSL

Notes:
- This header provides required dependencies for {{dsl-name}} DSL generated classes
- This is the TARGET_LANGUAGE target implementation of the {{dsl-name}} DSL header"
                 :eyeball "Performs sanity checks on generated TARGET_LANGUAGE code for the {{dsl-name}} DSL.

Checks:
- Basic structure validation
- Required components presence

Example:
Input: Generated TARGET_LANGUAGE code
Output: Status and any issues found

Notes:
- Ensures generated code follows the required structure
- Verifies all necessary components are present
- This is the TARGET_LANGUAGE target implementation of the {{dsl-name}} DSL eyeball function"
                 }
       }
      }
     }))

;; Return both functions as a map - this is the last expression in the file
{:get-metadata get-metadata
 :get-plugin get-plugin} 