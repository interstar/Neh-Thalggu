(ns makedsl.test.makedsl-test
  (:require [clojure.test :refer :all]
            [neh-thalggu.plugin-loader :as loader]
           
            [neh-thalggu.schema :as schema]
            [clojure.string :as string]
            [malli.core :as m]))

(def plugin-dir "plugins")
(def makedsl-dsl (loader/load-plugin plugin-dir "makedsl"))

(println "Testing makedsl DSL")
(println "Valid plugin? " (m/validate schema/plugin-schema makedsl-dsl))
(println "makedsl-dsl result: " makedsl-dsl)
(println "makedsl-dsl type: " (type makedsl-dsl))
(println "makedsl-dsl keys: " (when makedsl-dsl (keys makedsl-dsl)))

(def compile-fn (-> makedsl-dsl :targets (get "clojure") :compile-fn))
(def header-fn (-> makedsl-dsl :targets (get "clojure") :header-fn))
(def eyeball-fn (-> makedsl-dsl :targets (get "clojure") :eyeball-fn))

(defn compile-success? [compile-result] (:success compile-result))
(defn compile-failure? [compile-result] (not (:success compile-result)))

(deftest schema-check
  (testing "Schema check"
    (is (m/validate schema/plugin-schema makedsl-dsl))))

(deftest two-function-pattern
  (testing "makedsl plugin follows two-function pattern"
    (let [plugin-fns (load-file (str plugin-dir "/makedsl/dsl.clj"))
          metadata ((-> plugin-fns :get-metadata))
          plugin ((-> plugin-fns :get-plugin) loader/tag-path {})]
      (is (m/validate schema/plugin-metadata-schema metadata))
      (is (m/validate schema/plugin-schema plugin)))))

(deftest generated-templates-use-two-function-pattern
  (testing "Generated templates suggest using two-function pattern"
    (let [input "Name: twopattern\nDescription: Testing two-function pattern\nS = A\nA = 'a'"
          result (compile-fn input)
          generated-dsl (first (:code result))]
      (is (compile-success? result))
      ;; Check that generated DSL includes get-metadata function
      (is (string/includes? generated-dsl "defn get-metadata"))
      ;; Check that generated DSL includes get-plugin function
      (is (string/includes? generated-dsl "defn get-plugin"))
      ;; Check that generated DSL returns function map
      (is (string/includes? generated-dsl "{:get-metadata get-metadata"))
      (is (string/includes? generated-dsl ":get-plugin get-plugin}")))))

(deftest generated-foreign-templates-use-two-function-pattern
  (testing "Generated foreign templates suggest using two-function pattern"
    (let [foreign-compile-fn (-> makedsl-dsl :targets (get "foreign") :compile-fn)
          input "Name: foreigntwopattern\nDescription: Testing foreign two-function pattern\nS = A\nA = 'a'"
          result (foreign-compile-fn input)
          generated-dsl (first (:code result))]
      (is (compile-success? result))
      ;; Check that generated foreign DSL includes get-metadata function
      (is (string/includes? generated-dsl "defn get-metadata"))
      ;; Check that generated foreign DSL includes get-plugin function
      (is (string/includes? generated-dsl "defn get-plugin"))
      ;; Check that generated foreign DSL returns function map
      (is (string/includes? generated-dsl "{:get-metadata get-metadata"))
      (is (string/includes? generated-dsl ":get-plugin get-plugin}")))))

(deftest plugin-schema-validation
  (testing "makedsl plugin conforms to schema"
    (is (m/validate schema/plugin-schema makedsl-dsl))))

(deftest plugin-metadata-values
  (testing "makedsl plugin metadata values"
    (is (= "makedsl" (:name (:metadata makedsl-dsl))))
    (is (= "A meta-DSL for generating DSL plugins" (:description (:metadata makedsl-dsl))))))

(deftest header-generation-test
  (testing "Header generation"
    (let [result (header-fn)]
      (is (:success result))
      (is (string? (:code result)))
      (is (string/includes? (:code result) "instaparse"))
      (is (string/includes? (:code result) "clostache"))
      (is (string/includes? (:code result) "Example DSL definition format"))
      (is (m/validate schema/header-result-schema result)))))

(deftest valid-dsl-definition-test
  (testing "Valid DSL definition compilation"
    (let [input "Name: testlang
Description: A test language for generating code
S = SEQ
SEQ = \".\" | \"*\" SEQ"
          result (compile-fn input)]
      (is (compile-success? result))
      (is (vector? (:code result)))
      (is (= 3 (count (:code result)))) ; Should return dsl.clj, test.clj, and README.md
      (is (string? (first (:code result))))
      (is (string? (second (:code result))))
      (is (string? (nth (:code result) 2)))
      (is (string/includes? (first (:code result)) "(ns testlang.dsl"))
      (is (string/includes? (second (:code result)) "(ns testlang.test.testlang-test"))
      (is (string/includes? (nth (:code result) 2) "# testlang DSL"))
      (is (string/includes? (first (:code result)) "Generated by makedsl"))
      (is (m/validate schema/compile-result-schema result)))))

(deftest invalid-dsl-definition-test
  (testing "Invalid DSL definition compilation"
    (let [input "Name: testlang
Description: A test language
invalid grammar content"
          result (compile-fn input)]
      (is (compile-failure? result))
      (is (:error result))
      (is (m/validate schema/compile-result-schema result)))))

(deftest missing-dsl-name-test
  (testing "DSL definition without name"
    (let [input "Description: A test language
S = SEQ"
          result (compile-fn input)]
      (is (compile-failure? result))
      (is (:error result)))))

(deftest missing-description-test
  (testing "DSL definition without description"
    (let [input "Name: testlang
S = SEQ"
          result (compile-fn input)]
      (is (compile-failure? result))
      (is (:error result)))))

(deftest complex-grammar-test
  (testing "Complex grammar definition"
    (let [input "Name: complexlang
Description: A complex language with multiple rules
S = EXPR
EXPR = TERM | EXPR '+' TERM
TERM = FACTOR | TERM '*' FACTOR
FACTOR = NUMBER | '(' EXPR ')'
NUMBER = #'[0-9]+'"
          result (compile-fn input)]
      (is (compile-success? result))
      (is (string/includes? (first (:code result)) "complexlang"))
      (is (string/includes? (first (:code result)) "A complex language with multiple rules"))
      (is (m/validate schema/compile-result-schema result)))))

(deftest generated-dsl-structure-test
  (testing "Generated DSL has correct structure"
    (let [input "Name: structtest
Description: Testing structure
S = 'a'"
          result (compile-fn input)
          generated-dsl (first (:code result))]
      (is (compile-success? result))
      (is (string/includes? generated-dsl "(ns structtest.dsl"))
      (is (string/includes? generated-dsl "instaparse.core"))
      (is (string/includes? generated-dsl "clostache.parser"))
      (is (string/includes? generated-dsl "def grammar"))
      (is (string/includes? generated-dsl "def parser"))
      (is (string/includes? generated-dsl "defn compile-to-target"))
      (is (string/includes? generated-dsl "defn get-plugin"))
      (is (string/includes? generated-dsl "TARGET_LANGUAGE"))
      (is (string/includes? generated-dsl "Testing structure")))))

(deftest generated-dsl-grammar-parsing-test
  (testing "Generated DSL includes parse-grammar-rules function and uses it"
    (let [input "Name: grammartest
Description: Testing grammar parsing
S = EXPR
EXPR = TERM | EXPR '+' TERM
TERM = FACTOR | TERM '*' FACTOR
FACTOR = NUMBER | '(' EXPR ')'
NUMBER = #'[0-9]+'"
          result (compile-fn input)
          generated-dsl (first (:code result))]
      (is (compile-success? result))
      ;; Check that parse-grammar-rules function is generated
      (is (string/includes? generated-dsl "defn parse-grammar-rules"))
      (is (string/includes? generated-dsl "str/split-lines"))
      (is (string/includes? generated-dsl "str/includes? line \"=\""))
      ;; Check that get-plugin uses parse-grammar-rules
      (is (string/includes? generated-dsl "grammar-rules (parse-grammar-rules grammar)"))
      ;; Check that grammar rules are not hardcoded
      (is (not (string/includes? generated-dsl ":rules {\"S\"")))
      (is (not (string/includes? generated-dsl ":rules {\"EXPR\"")))
      ;; Check that grammar rules are derived from grammar variable
      (is (string/includes? generated-dsl ":rules grammar-rules"))
      ;; Check that start rule is set correctly
      (is (string/includes? generated-dsl ":start \"Schema\"")))))

(deftest generated-test-structure-test
  (testing "Generated test file has correct structure"
    (let [input "Name: teststruct
Description: Testing test structure
S = 'a'"
          result (compile-fn input)
          generated-test (second (:code result))]
      (is (compile-success? result))
      (is (string/includes? generated-test "(ns teststruct.test.teststruct-test"))
      (is (string/includes? generated-test "clojure.test"))
      (is (string/includes? generated-test "teststruct.dsl"))
      (is (string/includes? generated-test "deftest test-teststruct"))
      (is (string/includes? generated-test "get-plugin"))
      (is (string/includes? generated-test "TARGET_LANGUAGE")))))

(deftest generated-foreign-test-structure-test
  (testing "Generated foreign test file has correct structure"
    (let [foreign-compile-fn (-> makedsl-dsl :targets (get "foreign") :compile-fn)
          input "Name: foreigntest
Description: Testing foreign test structure
S = 'a'"
          result (foreign-compile-fn input)
          generated-test (second (:code result))]
      (is (compile-success? result))
      (is (string/includes? generated-test "(ns foreigntest.test.foreigntest-test"))
      (is (string/includes? generated-test "clojure.test"))
      (is (string/includes? generated-test "foreigntest.dsl"))
      (is (string/includes? generated-test "deftest test-foreigntest"))
      (is (string/includes? generated-test "get-plugin"))
      (is (string/includes? generated-test "load-java-class")))))

(deftest eyeball-valid-code-test
  (testing "Eyeball function with valid generated code"
    (let [code "(ns testlang.dsl
  (:require [instaparse.core :as insta]
            [clostache.parser :refer [render]]))

(defn get-plugin [tag-path]
  {:name \"testlang\"
   :targets {\"TARGET_LANGUAGE\" {:compile-fn (fn [s] s)
                                 :header-fn (fn [] \"header\")
                                 :eyeball-fn (fn [c] c)}}})"
          result (eyeball-fn code)]
      (is (= "seems ok" (:status result)))
      (is (empty? (:issues result)))
      (is (m/validate schema/eyeball-result-schema result)))))

(deftest eyeball-invalid-code-test
  (testing "Eyeball function with invalid code"
    (let [code "defn test [] \"hello\")"
          result (eyeball-fn code)]
      (is (= "issues" (:status result)))
      (is (not (empty? (:issues result))))
      (is (m/validate schema/eyeball-result-schema result)))))

(deftest eyeball-missing-components-test
  (testing "Eyeball function detects missing components"
    (let [code "(ns testlang.dsl)
(defn some-function [] \"hello\")"
          result (eyeball-fn code)]
      (is (= "issues" (:status result)))
      (is (some #(string/includes? % "Missing get-plugin function") (:issues result)))
      (is (some #(string/includes? % "Missing TARGET_LANGUAGE placeholder") (:issues result)))
      (is (m/validate schema/eyeball-result-schema result)))))

(deftest function-schema-validation-test
  (testing "All plugin functions return correct schemas"
    (let [valid-input "Name: schematest
Description: Testing schemas
S = A"]
      (is (m/validate schema/compile-result-schema (compile-fn valid-input)))
      (is (m/validate schema/header-result-schema (header-fn)))
      (is (m/validate schema/eyeball-result-schema (eyeball-fn "test code"))))))

(deftest grammar-parsing-edge-cases-test
  (testing "Edge cases in grammar parsing"
    (testing "Empty grammar"
      (let [input "Name: empty
Description: Empty grammar

"
            result (compile-fn input)]
        (is (compile-failure? result))
        (is (:error result))))
    
    (testing "Single rule grammar"
      (let [input "Name: single
Description: Single rule
S = 'hello'"
            result (compile-fn input)]
        (is (compile-success? result))))
    
    (testing "Grammar with special characters"
      (let [input "Name: special
Description: Special chars
S = #'[a-z]+' | #'[0-9]+'"
            result (compile-fn input)]
        (is (compile-success? result))))))

(deftest error-handling-test
  (testing "Error handling in various scenarios"
    (testing "Missing grammar"
      (let [input "Name: missing
Description: Missing grammar"
            result (compile-fn input)]
        (is (compile-failure? result))
        (is (:error result))))
    
    (testing "Empty input"
      (let [result (compile-fn "")]
        (is (compile-failure? result))
        (is (:error result))))))

(run-tests)
