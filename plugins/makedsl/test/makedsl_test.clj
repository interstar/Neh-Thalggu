(ns makedsl.test.makedsl-test
  (:require [clojure.test :refer :all]
            [dsl-mcp-server.plugin-loader :as loader]
            [malli.core :as m]
            [dsl-mcp-server.schema :as schema]
            [clojure.string :as string]))

(def plugin-dir "plugins")
(def makedsl-dsl (loader/load-plugin plugin-dir "makedsl"))

(println "Testing makedsl DSL")
(println "Valid plugin? " (m/validate schema/plugin-schema makedsl-dsl))

(def compile-fn (-> makedsl-dsl :targets (get "clojure") :compile-fn))
(def header-fn (-> makedsl-dsl :targets (get "clojure") :header-fn))
(def eyeball-fn (-> makedsl-dsl :targets (get "clojure") :eyeball-fn))

(defn compile-success? [compile-result] (:success compile-result))
(defn compile-failure? [compile-result] (not (:success compile-result)))

(deftest schema-check
  (testing "Schema check"
    (is (m/validate schema/plugin-schema makedsl-dsl))))

(deftest plugin-structure-test
  (testing "Plugin has correct structure"
    (is (= "makedsl" (:name makedsl-dsl)))
    (is (= "A meta-DSL for generating DSL plugins" (:description makedsl-dsl)))
    (is (contains? (:targets makedsl-dsl) "clojure"))
    (is (fn? compile-fn))
    (is (fn? header-fn))
    (is (fn? eyeball-fn))))

(deftest header-generation-test
  (testing "Header generation"
    (let [result (header-fn)]
      (is (:success result))
      (is (string? (:code result)))
      (is (string/includes? (:code result) "instaparse"))
      (is (string/includes? (:code result) "clostache"))
      (is (string/includes? (:code result) "Example DSL definition format"))
      (is (m/validate schema/header-result-schema result)))))

(deftest valid-dsl-definition-test
  (testing "Valid DSL definition compilation"
    (let [input "Name: testlang
Description: A test language for generating code
S = SEQ
SEQ = \".\" | \"*\" SEQ"
          result (compile-fn input)]
      (is (compile-success? result))
      (is (vector? (:code result)))
      (is (= 3 (count (:code result)))) ; Should return dsl.clj, test.clj, and README.md
      (is (string? (first (:code result))))
      (is (string? (second (:code result))))
      (is (string? (nth (:code result) 2)))
      (is (string/includes? (first (:code result)) "(ns testlang.dsl"))
      (is (string/includes? (second (:code result)) "(ns testlang.test"))
      (is (string/includes? (nth (:code result) 2) "# testlang DSL"))
      (is (string/includes? (first (:code result)) "Generated by makedsl"))
      (is (m/validate schema/compile-result-schema result)))))

(deftest invalid-dsl-definition-test
  (testing "Invalid DSL definition compilation"
    (let [input "Name: testlang
Description: A test language
invalid grammar content"
          result (compile-fn input)]
      (is (compile-failure? result))
      (is (:error result))
      (is (m/validate schema/compile-result-schema result)))))

(deftest missing-dsl-name-test
  (testing "DSL definition without name"
    (let [input "Description: A test language
S = SEQ"
          result (compile-fn input)]
      (is (compile-failure? result))
      (is (:error result)))))

(deftest missing-description-test
  (testing "DSL definition without description"
    (let [input "Name: testlang
S = SEQ"
          result (compile-fn input)]
      (is (compile-failure? result))
      (is (:error result)))))

(deftest complex-grammar-test
  (testing "Complex grammar definition"
    (let [input "Name: complexlang
Description: A complex language with multiple rules
S = EXPR
EXPR = TERM | EXPR '+' TERM
TERM = FACTOR | TERM '*' FACTOR
FACTOR = NUMBER | '(' EXPR ')'
NUMBER = #'[0-9]+'"
          result (compile-fn input)]
      (is (compile-success? result))
      (is (string/includes? (first (:code result)) "complexlang"))
      (is (string/includes? (first (:code result)) "A complex language with multiple rules"))
      (is (m/validate schema/compile-result-schema result)))))

(deftest generated-dsl-structure-test
  (testing "Generated DSL has correct structure"
    (let [input "Name: structtest
Description: Testing structure
S = 'a'"
          result (compile-fn input)
          generated-dsl (first (:code result))]
      (is (compile-success? result))
      (is (string/includes? generated-dsl "(ns structtest.dsl"))
      (is (string/includes? generated-dsl "instaparse.core"))
      (is (string/includes? generated-dsl "clostache.parser"))
      (is (string/includes? generated-dsl "def grammar"))
      (is (string/includes? generated-dsl "def parser"))
      (is (string/includes? generated-dsl "defn compile-to-target"))
      (is (string/includes? generated-dsl "defn get-plugin"))
      (is (string/includes? generated-dsl "TARGET_LANGUAGE"))
      (is (string/includes? generated-dsl "Testing structure")))))

(deftest generated-test-structure-test
  (testing "Generated test file has correct structure"
    (let [input "Name: teststruct
Description: Testing test structure
S = 'a'"
          result (compile-fn input)
          generated-test (second (:code result))]
      (is (compile-success? result))
      (is (string/includes? generated-test "(ns teststruct.test"))
      (is (string/includes? generated-test "clojure.test"))
      (is (string/includes? generated-test "teststruct.dsl"))
      (is (string/includes? generated-test "deftest test-teststruct"))
      (is (string/includes? generated-test "get-plugin"))
      (is (string/includes? generated-test "TARGET_LANGUAGE")))))

(deftest eyeball-valid-code-test
  (testing "Eyeball function with valid generated code"
    (let [code "(ns testlang.dsl
  (:require [instaparse.core :as insta]
            [clostache.parser :refer [render]]))

(defn get-plugin [tag-path]
  {:name \"testlang\"
   :targets {\"TARGET_LANGUAGE\" {:compile-fn (fn [s] s)
                                 :header-fn (fn [] \"header\")
                                 :eyeball-fn (fn [c] c)}}})"
          result (eyeball-fn code)]
      (is (= "seems ok" (:status result)))
      (is (empty? (:issues result)))
      (is (m/validate schema/eyeball-result-schema result)))))

(deftest eyeball-invalid-code-test
  (testing "Eyeball function with invalid code"
    (let [code "defn test [] \"hello\")"
          result (eyeball-fn code)]
      (is (= "issues" (:status result)))
      (is (not (empty? (:issues result))))
      (is (m/validate schema/eyeball-result-schema result)))))

(deftest eyeball-missing-components-test
  (testing "Eyeball function detects missing components"
    (let [code "(ns testlang.dsl)
(defn some-function [] \"hello\")"
          result (eyeball-fn code)]
      (is (= "issues" (:status result)))
      (is (some #(string/includes? % "Missing get-plugin function") (:issues result)))
      (is (some #(string/includes? % "Missing TARGET_LANGUAGE placeholder") (:issues result)))
      (is (m/validate schema/eyeball-result-schema result)))))

(deftest function-schema-validation-test
  (testing "All plugin functions return correct schemas"
    (let [valid-input "Name: schematest
Description: Testing schemas
S = A"]
      (is (m/validate schema/compile-result-schema (compile-fn valid-input)))
      (is (m/validate schema/header-result-schema (header-fn)))
      (is (m/validate schema/eyeball-result-schema (eyeball-fn "test code"))))))

(deftest grammar-parsing-edge-cases-test
  (testing "Edge cases in grammar parsing"
    (testing "Empty grammar"
      (let [input "Name: empty
Description: Empty grammar

"
            result (compile-fn input)]
        (is (compile-failure? result))
        (is (:error result))))
    
    (testing "Single rule grammar"
      (let [input "Name: single
Description: Single rule
S = 'hello'"
            result (compile-fn input)]
        (is (compile-success? result))))
    
    (testing "Grammar with special characters"
      (let [input "Name: special
Description: Special chars
S = #'[a-z]+' | #'[0-9]+'"
            result (compile-fn input)]
        (is (compile-success? result))))))

(deftest error-handling-test
  (testing "Error handling in various scenarios"
    (testing "Missing grammar"
      (let [input "Name: missing
Description: Missing grammar"
            result (compile-fn input)]
        (is (compile-failure? result))
        (is (:error result))))
    
    (testing "Empty input"
      (let [result (compile-fn "")]
        (is (compile-failure? result))
        (is (:error result))))))

(run-tests)