(ns wchnt.dsl
  (:require [instaparse.core :as insta]
            [clojure.string :as str]))

(def grammar
  "Schema = DefLine (<NL> DefLine)*
   DefLine = Definee <SPACE> '=' <SPACE> Element (<SPACE> Element)* <SPACE>?
   Definee = Name
   <Name> = #'[A-Za-z][A-Za-z0-9_]*'
   NL = #'\\n+'
   Element = Type ('/' AltName)?
   SPACE = #'\\s+'
   Type = Name
   AltName = Name")

(def parser (insta/parser grammar))

(defn generate-haxe-class [class-name elements]
  (let [fields (for [element elements]
                 (let [field-name (:name element)
                       field-type (:type element)]
                   (str "    public var " field-name ": " field-type ";")))
        constructor-params (for [element elements]
                            (let [field-name (:name element)
                                  field-type (:type element)]
                              (str field-type " " field-name)))
        constructor-body (for [element elements]
                          (let [field-name (:name element)]
                            (str "        this." field-name " = " field-name ";")))
        class-code (str "class " class-name " {\n"
                       (str/join "\n" fields)
                       "\n\n"
                       "    public function new(" (str/join ", " constructor-params) ") {\n"
                       (str/join "\n" constructor-body)
                       "\n    }\n"
                       "}")]
    class-code))

(defn find-node [tag tree]
  (cond
    (and (vector? tree) (= (first tree) tag)) tree
    (vector? tree) (some #(find-node tag %) (rest tree))
    (seq? tree) (some #(find-node tag %) tree)
    :else nil))

(defn process-element [children]
  (let [type-node (find-node :Type children)
        alt-name-node (find-node :AltName children)
        type-name (second type-node)
        alt-name (when alt-name-node (second alt-name-node))
        result {:type type-name
               :name (or alt-name (str (str/lower-case (subs type-name 0 1)) (subs type-name 1)))}]
    (println "DEBUG: Element result =" (pr-str result))
    result))

(defn process-def-line [children]
  (let [definee-node (first (filter #(= (first %) :Definee) children))
        element-nodes (filter #(= (first %) :Element) children)
        class-name (second definee-node)
        _ (println "DEBUG: class-name =" class-name)
        _ (println "DEBUG: element-nodes =" (pr-str element-nodes))
        processed-elements (map process-element element-nodes)
        _ (println "DEBUG: processed-elements =" (pr-str processed-elements))
        haxe-class (generate-haxe-class class-name processed-elements)
        _ (println "DEBUG: haxe-class =" haxe-class)]
    haxe-class))

(defn walk-tree [node]
  (cond
    (string? node) []
    (vector? node)
    (let [[tag & children] node]
      (case tag
        :Schema (vec (mapcat walk-tree (filter vector? children)))
        :DefLine [(process-def-line children)]
        :Definee []
        :Element []
        :Type []
        :AltName []
        (vec (mapcat walk-tree (filter vector? children)))))
    :else []))

(defn compile-to-haxe [input tag-path-fn]
  (try
    (let [parse-result (parser input)]
      (if (insta/failure? parse-result)
        {:success false
         :code [""]
         :notes (str input " is not a valid string in wchnt")
         :warning "See :error"
         :error (-> parse-result insta/get-failure bean str)}
        (let [classes (walk-tree parse-result)]
          {:success true
           :code classes
           :notes "Generated Haxe classes from wchnt schema"
           :warning ""
           :error nil})))
    (catch Exception e
      {:success false
       :code [""]
       :notes "Error during compilation"
       :warning "See :error"
       :error (str e)})))

(defn haxe-header []
  {:success true
   :code "// Generated by wchnt DSL
// All classes are immutable with public fields
// No setters are provided - objects are constructed once and never modified"
   :notes "Header information for wchnt-generated Haxe classes"
   :warning ""})

(defn haxe-eyeball [code]
  (let [issues (cond-> []
                 (not (str/includes? code "class"))
                 (conj "Missing class declarations")
                 (not (str/includes? code "public var"))
                 (conj "Missing public field declarations")
                 (not (str/includes? code "public function new"))
                 (conj "Missing constructor")
                 (not (str/includes? code "this."))
                 (conj "Missing field assignments in constructor")
                 (str/includes? code "set")
                 (conj "Classes should be immutable - no setters allowed")
                 (str/includes? code "private")
                 (conj "All fields should be public"))]
    {:status (if (empty? issues) "seems ok" "issues")
     :issues issues
     :notes "Checks for required Haxe class structure and immutability"}))

(defn get-plugin [tag-path]
  (let [dslname "wchnt"]
    {:name dslname
     :description "A DSL for defining data schemas that compile to Haxe classes"
     :version "1.0.0"
     :author "Generated by makedsl, customized for Haxe"
     :grammar
     {:rules {"Schema" "DefLine (<NL> DefLine)*"
              "DefLine" "Definee <SPACE> '=' <SPACE> Element (<SPACE> Element)* <SPACE>?"
              "Definee" "Name"
              "<Name>" "#'[A-Za-z][A-Za-z0-9_]*'"
              "NL" "#'\\n+'"
              "Element" "Type ('/' AltName)?"
              "<SPACE>" "#'\\s+'"
              "Type" "Name"
              "AltName" "Name"}
      :start "Schema"}
     :targets
     {"haxe"
      {:description "Generate Haxe classes from wchnt schema definitions"
       :compile-fn (fn [s] (compile-to-haxe s tag-path))
       :header-fn haxe-header
       :eyeball-fn haxe-eyeball
       :prompts {
                 :compile "Compiles wchnt DSL input to Haxe class definitions.

Arguments:
- dsl: The wchnt DSL input defining object schemas (required)

Example:
Input: 
Game = PlayArea Ball Paddle/paddle1 Paddle/paddle2
PlayArea = Rect
Ball = int/x int/y int/dx int/dy int/rad
Paddle = int/x int/y
Rect = int/x int/y int/width int/height

Output:
class Game {
    public var playArea: PlayArea;
    public var ball: Ball;
    public var paddle1: Paddle;
    public var paddle2: Paddle;

    public function new(playArea: PlayArea, ball: Ball, paddle1: Paddle, paddle2: Paddle) {
        this.playArea = playArea;
        this.ball = ball;
        this.paddle1 = paddle1;
        this.paddle2 = paddle2;
    }
}

Notes:
- Each line defines a class and its components
- Components without '/' get default names (lowercase first letter)
- Components with '/altname' get the specified alternative name
- All classes are immutable with public fields
- Constructors take all components as parameters
- This is the Haxe target implementation of the wchnt DSL"
                 :header "Gets the required header information for wchnt-generated Haxe classes.

Example Output:
// Generated by wchnt DSL
// All classes are immutable with public fields
// No setters are provided - objects are constructed once and never modified

Notes:
- This header provides context about the generated Haxe classes
- All classes follow immutable pattern with public fields
- No setters are generated - objects are constructed once
- This is the Haxe target implementation of the wchnt DSL header"
                 :eyeball "Performs sanity checks on generated Haxe code for the wchnt DSL.

Checks:
- Class declarations present
- Public field declarations present
- Constructor with parameters present
- Field assignments in constructor
- No setters (immutability)
- All fields public

Example:
Input: Generated Haxe code
Output: Status and any issues found

Notes:
- Ensures generated code follows wchnt DSL conventions
- Verifies immutable class structure
- Checks for required Haxe syntax
- This is the Haxe target implementation of the wchnt DSL eyeball function"
                 }
       }
      }
     })) 